from Cryptopals_main import *
from MT19937 import MT19937

## Challenge 3-1
def challenge_3_1():

    # Randomly encrypt a random string from Challenge_3-17.txt
    c3_1 = AESCode(key='random', iv='random')  # Random cipher

    # Create function that randomly returns a string from Challenge_3-17.txt as a byte
    c3_1_rand_byte_fun = create_rand_byte_fun('Challenge_3-17.txt', 'b64')

    # Create oracle out of random cipher and byte generator
    c3_1_oracle = c3_1.gen_cbc_oracle_rand(c3_1_rand_byte_fun)

    # See example generation
    c3_1.easybyte.b = c3_1_oracle()
    print(c3_1.easybyte.b)

    # As in previous challenges, AESCode.cbc_solve solves the cipher and attempts to unpad
    # An error will be raised if unpadding runs into a problem (ex: incorrect padding)
    c3_1.cbc_solve()


challenge_3_1()

## Challenge 3-2
def challenge_3_2():
    c3_2_ciphertext = 'L77na/nrFsKvynd6HzOoG7GHTLXsTVu9qvY/2syLXzhPweyyMTJULu/6/kXX0KSvoOLSFQ=='
    c3_2 = AESCode(c3_2_ciphertext, 'b64', key=b'YELLOW SUBMARINE', nonce=empty_bytes(8))
    print(c3_2.ctr())


challenge_3_2()

## Challenge 3-4
def challenge_3_4a():
    # Find length of shortest line
    c3_4 = ListVCode('Challenge_3-20.txt', 'b64')
    c3_4.truncate_and_join()


challenge_3_4a()

## Challenge 3-4b
def challenge_3_4b(key_l):
    # Truncate and join, find repeating key of length the shortest line
    c3_4 = ListVCode('Challenge_3-20.txt', 'b64')
    c3_4_code = c3_4.truncate_and_join()
    c3_4_code.find_v_key(key_l)
    print(c3_4_code.key_poss)


challenge_3_4b(53)

## Challenge 3-4c
def challenge_3_4c(key):
    # Solve
    c3_4 = ListVCode('Challenge_3-20.txt', 'b64')
    for code in c3_4.codes:
        code.key = key  # Set key as what we found previously
        code.solve()


challenge_3_4c(b'\x00')

## Challenge 3-5
# Implement the MT19937 Mersenne Twister RNG
def challenge_3_5(seed):
    print(MT19937(seed).rand_num_gen())


challenge_3_5(321)

## Challenge 3-7
# Clone an MT19937 RNG from its output

def challenge_3_7_a(seed: int):
    # Creates and clones MT19937 RNG given a seed
    c3_7_rng = MT19937(seed)
    c3_7_clone = MT19937()
    return c3_7_clone.clone(c3_7_rng.rand_num_gen)

def challenge_3_7_b(seed: int, n: int):
    # Checks the clone gives the same output as the original in the first n trials
    c3_7_original = MT19937(seed)
    c3_7_clone = challenge_3_7_a(seed)

    for i in range(n):
        assert c3_7_original.rand_num_gen() == c3_7_clone.rand_num_gen()

    print(f'Clone appears to work based on {n} trials')


challenge_3_7_b(234, 1000)

## Challenge 3-8

def challenge_3_8(btext, seed):
    # Takes text, XOR's it against stream generated by MT19937 RNG with given seed
    # Repeats the process with ciphertext to check we're back where we started

    # Obtain stream from RNG
    c3_8_stream = MT19937(seed).stream()

    # Declare stream cipher
    c3_8_text = btext
    c3_8 = StreamCipher(c3_8_text, stream=c3_8_stream)

    # Encode
    encoded = c3_8.encode()
    print(f'Encoded text:\n{encoded}\n')

    # Reinitiate stream
    c3_8_stream = MT19937(seed).stream()

    # Declare stream cipher
    c3_8 = StreamCipher(encoded, stream=c3_8_stream)

    # Decode (same code as for encoding)
    og_text = c3_8.encode()

    assert og_text == btext  # Check we're back where we started
    print('Cipher successfully reversed itself !')
    print(og_text)


challenge_3_8(b'Honis soit qui mal y pense', 1729)
